' ------------------------------------------------------------------------------
' SINE - CORE SCRIPT USED BY ALL SINE PROTOCOLS (REQUIRES SPIKE2 VERSION 10)
'
' Contains variables/functions that are shared by all sine protocols
' ------------------------------------------------------------------------------
' Define the parent directory all other paths will be relative to
const rootpath$ := "C:/Users/Public/RaymondLabCode2/spike2_experimental_protocols";
FilePathSet(rootpath$, 0);

' These files are the same for ALL EXPERIMENTAL protocols
#include "../utils/read_write_rig_params.s2s"
#include "../utils/sampling_window_config.s2s"
#include "../utils/unit_conversion_functions.s2s"

' Load rig-specific parameters from local-computer's registry
LoadRigParams();

' Test and Training block parameters
var nTestBlocks%       := 3;      'Number of pre/post-training test blocks [default 3]
var testBlockDuration  := 45.0;   'Total duration (s) of test blocks [default 45.0]
var nTrainingBlocks%   := 6;      'Number of training blocks [default 6]
var trainBlockDuration := 300.0;  'Total duration (s) of training block(s) [default 300.0]
var trainingType%      := 0;      'Defines the training type for the experiment [default 0]

' Gap block parameters
var gapDur   := 5.0;  'Total duration (in seconds) of each gap block [default 5.0]
var flashDur := 0.2;  'Duration of TTL flash (in seconds) halfway into each gap block [default 0.2]

' Drum stimulus default sine parameters
var drumAmp           := -10.0;             'Drum amplitude in deg/s [default -10.0]
var drumFreq          := 1;                 'Drum frequency in Hz [default 1]
var drumPeriod        := 1/drumFreq;        'Drum period in seconds
var drumPhase         := 0;                 'Drum phase in degrees [default 0]
var nDrumTestCycles%, nDrumTrainCycles%;    'Number of drum TEST and TRAIN block cyles

' Chair stimulus default sine parameters
var chairAmp       := 10.0;                 'In deg/s [default 10.0]
var chairFreq      := 1;                    'In Hz [default 1]
var chairPeriod    := 1/chairFreq;          'In seconds 
var chairPhase     := 0;                    'In degrees [default 0]
var chairDirection := 1;                    '0 for ipsi, 1 for contra
var nChairTestCycles%, nChairTrainCycles%;  'Number of chair TEST and TRAIN block cyles

' driftFix parameters
var Kp            := 0.45;  'Proportional correction gain [default 0.45]
var Ki            := 0.54;  'Integral correction gain [default 0.54]
var intErrorLimit := 0.3;   'Integral clamping limit [default 0.3]
var numErrors%    := 3;     'Number of error values to collect in an array [default 3]
var htposErrors[numErrors%], hhposErrors[numErrors%];  'Array of (proportional) errors
var htposIntError, hhposIntError, intErrorMax;  'Cumulative (integral) error

' ToolbarIdle% global variables
var nBlocks%, blockList$[1], blockLabelList$[1];
var blockNum%;      'Counter which defines which block number is currently active
var blockFlag%;     'Flag which defines whether a block is actively running or not
var blockMarkers$;  'Provides the SampleKey commands for the currently active block
var runFlag%;       'Flag which denotes whether the experiment is activately running or not
var lowerSampleKey$, upperSampleKey$;
var pretestBlockNum%, trainBlockNum%, posttestBlockNum%;
var blockStartTime, blockEndTime;

' Set initial number of test and train block cyles
SetNumTestTrainCycles();


'--------------------------------------------------------------------------------
' DRIFTFIX: Applies velocity offset correction when necessary
'
' Applies Proportional-Integral (PI) control such that the output velocity offset 
' v(t) is given by the formula:
'
' v(t) = v(0) - Kp*e(t) - Ki*Int[e(t)*dt]
' 
' Where:
' v(0)         - Initial velocity offset of the motor
' Kp           - Proportional gain
' e(t)         - Average feedback position error 
' Ki           - Integral gain
' Int[e(t)*dt] - Cumulative sum of errors over time 
'
' Notes:
' 1. We further "soften" the e(t) term by averaging over previous numErrors% errors.
' 2. We control windup by clamping the absolute integral error to intErrorMax.
'--------------------------------------------------------------------------------
Func driftFix%()
    ' Get the current sampling time
    var currentTime := MaxTime();

    ' Shift array of errors by one element
    ArrConst(htposErrors[1:numErrors%-1], htposErrors[0:numErrors%-1]);
    ArrConst(hhposErrors[1:numErrors%-1], hhposErrors[0:numErrors%-1]);

    ' Error is defined as the mean position over a cycle period (which should be zero)
    htposErrors[0] := ChanMeasure(htpos_ch%, 2, currentTime-drumPeriod, currentTime);
    hhposErrors[0] := ChanMeasure(hhpos_ch%, 2, currentTime-chairPeriod, currentTime);

    ' Error is "softened" by using the mean of errors over the last numErrors% errors
    var htposCurrError := ArrSum(htposErrors) / numErrors%;
    var hhposCurrError := ArrSum(hhposErrors) / numErrors%;

    ' Final Proportional error term
    var htposProportionalError := Kp * htposCurrError;
    var hhposProportionalError := Kp * hhposCurrError;

    ' Integral error term is the scaled cumulative sum of errors
    var htposIntErrorTest := htposIntError + (Ki * htposCurrError * sampleStepsize);
    var hhposIntErrorTest := hhposIntError + (Ki * hhposCurrError * sampleStepsize);

    ' Apply anti-windup integral condition (only increase IntError if below limit)
    if Abs(htposIntErrorTest) <= intErrorLimit then
        htposIntError := htposIntErrorTest;
    endif;
    if Abs(hhposIntErrorTest) <= intErrorLimit then
        hhposIntError := hhposIntErrorTest;
    endif;

    ' Final Integral error term
    var htposIntegralError := htposIntError;
    var hhposIntegralError := hhposIntError;

    ' Apply PI error correction to the drum and chair velocity offset commands
    var drumVelocityOffsetCorrection  := 0 - htposProportionalError - htposIntegralError;
    var chairVelocityOffsetCorrection := 0 - hhposProportionalError - hhposIntegralError;
    drumVelocityOffset  := drumVelocityOffsetInitial + drumVelocityOffsetCorrection;
    chairVelocityOffset := chairVelocityOffsetInitial + chairVelocityOffsetCorrection;

    'PrintLog("Drum (P=%.5f,I=%.5f,T=%.5f) | Chair (P=%.5f,I=%.5f,T=%.5f)\n", 
    '    htposProportionalError, htposIntegralError, drumVelocityOffsetCorrection,
    '    hhposProportionalError, hhposIntegralError, chairVelocityOffsetCorrection);    

    ' Update the sequencer variables with the corrected velocity offsets
    SetSequencerValues();
    return 1;
End


'--------------------------------------------------------------------------------
' GENERAL TOOLBAR FUNCTIONS
'--------------------------------------------------------------------------------

' Function that defines what happens during idle times (in computer cycles) while actively sampling
Func ToolbarIdle%()
    ' Check whether a valid sampling view is currently running before continuing
    if ViewKind() <> 0 then
        return 1;
    endif;
    ' Check whether motors are drifting and apply correction if needed
    driftFix%();
    if runFlag% = 1 then  'Check whether the "Run Experiment" button was pressed
        blockFlag% := SampleSeqVar(1);  'Get the current blockFlag% value from the 1401 sequencer variable
        if blockFlag% = 0 then  'Check whether a block is not currently running
            if blockNum% > 0 then
                blockEndTime := MaxTime();
                lowerSampleKey$ := Right$(blockMarkers$, 1);
                SampleKey(lowerSampleKey$);  'Sends a lower-case keyboard command that defines the end of a block (useful only for analysis)
                PrintLog("Sample time: %.4f seconds | Block number: %d of %d | Block marker: %s\n", blockEndTime, blockNum%, nBlocks%, lowerSampleKey$);
            endif; 
            if blockNum% < nBlocks% then  'Check whether current block number is not greater than or equal to maximum number of blocks
                blockStartTime := MaxTime();
                blockMarkers$ := blockList$[blockNum%];
                upperSampleKey$ := Left$(blockMarkers$, 1);
                SampleKey(upperSampleKey$);  'Send SampleKey() command to the 1401 sequencer of the current block's letter marker
                AddTextMark(upperSampleKey$, blockNum%);
                blockNum% := blockNum% + 1;  'Increase the block number by one
                PrintLog("Sample time: %.4f seconds | Block number: %d of %d | Block marker: %s\n", blockStartTime, blockNum%, nBlocks%, upperSampleKey$);
            else
                runFlag% := 0;  'Set experiment flag to off
                SampleKey("R");  'Reset 1401 sequencer to initial state
                SampleText("END", -1, 0); 
                SampleKey("a");  'Sends a lower-case keyboard command that defines the end of the experiment (useful only for analysis)
                ToolbarSet(40, "Run Expmt", ToolbarRunExpmt%);
                PrintLog("EXPERIMENT COMPLETE!\n\n");
                Yield(2);
                XRange();  'Zoom out to view entire experiement
            endif;
        endif;
    endif;
    return 1;
End

' Function that opens a new sampling window
Func ToolbarNewFile%()
    WindowSetup();         'Sets up channels in the new sampling configuration window
    WindowUpdate();        'Updates sampling window with protocol-specific configuration
    WindowVisible(3);      'Maximizes the new sampling window to fit the screen
    ToolbarEnable(-1, 1);  'Enables buttons that require a new sampling window
    ToolbarEnable(2, 0); 
    SetSequencerValues(); Yield();
    SampleKey("R");  'Ensures that sequencer is set to its default configuration prior to sampling
    return 1;
End

' Function that runs experiment based on parameters provided in experimental configuration window
Func ToolbarRunExpmt%()
    SampleKey("A");
    SetSequencerValues();
    SampleText("START", -1, 0); 
    ToolbarSet(40, "Stop Expmt", ToolbarStopExpmt%);
    Yield(2);
    runFlag% := 1;
    return 1;
End

' Function that runs experiment based on parameters provided in experimental configuration window
Func ToolbarStopExpmt%()
    SampleKey("R");
    SampleKey("a");
    runFlag% := 0;
    SampleText("END", -1, 0); 
    ToolbarSet(40, "Run Expmt", ToolbarRunExpmt%);
    return 1;
End

' Function that stops all stimuli, resets the sequencer to default, and quits out of the toolbar
Func ToolbarQuit%()
    SampleKey("R");
    SampleKey("a");
    SampleStop();
    PrintLog("MANUALLY QUIT!\n\n");
    return 0;
End

' Set number of test and train block cyles based on block duration and stim frequency
Proc SetNumTestTrainCycles()
    nDrumTestCycles%   := Round(testBlockDuration / drumFreq);    'Number of drum TEST block cycles
    nDrumTrainCycles%  := Round(trainBlockDuration / drumFreq);   'Number of drum TRAIN block cycles
    nChairTestCycles%  := Round(testBlockDuration / chairFreq);   'Number of drum TEST block cycles
    nChairTrainCycles% := Round(trainBlockDuration / chairFreq);  'Number of drum TRAIN block cycles
End