' ------------------------------------------------------------------------------
' SINE - SINGLE TRIAL OPTOSTIM EXPERIMENTAL PROTOCOL (REQUIRES SPIKE2 VERSION 10)
'
' Values for local (rig-specific) variables are stored in the system registry: 
' HKEY_CURRENT_USER\Software\CED\Spike2\RigParams
' 
' ------------------------------------------------------------------------------

' Set the sequencer file to use for the protocol
const sequencerFile$ := "sine_protocols/sine_opto_st-bilateral-doubles.pls";

' This file is the same for all SINE protocols
#include "sine_core.s2s"

' Overwrite the default parameter values with protocol-specific values
nTestBlocks%       := 3;     'Number of pretest/posttest blocks [default 3]
testBlockDuration  := 45;    'Duration (s) of each pretest/posttest block [default 45.0]
nTrainingBlocks%   := 1;     'Number of training blocks [default 1]
trainBlockDuration := 1800;  'Duration (s) of each training block [default 1800.0]

' Re-calculate number of test and train block cyles
SetNumTestTrainCycles();

' Define the base opto timing delays for each experiment type ("-1" corresponds to "no stim")
const delays0p5Hz%[] := {0, 125, 250, 375, 500, 625, 750, 875, 1000, 1125, 1250, 1375, 1500, 1625, 1750, 1875, -1};
const delays1Hz%[]   := {0, 125, 188, 250, 313, 375, 500, 625, 750, 875, -1};
const delays2Hz%[]   := {0, 63, 125, 188, 250, 313, 375, 438, -1};

' "Opto Settings" default parameters
var imageArr%[3], optoDuration%;
var optoTrainingType%  := 0;  'Defines the frequency of the training for opto experiments [default 0]
var optoTimingOrder%   := 0;  'Defines whether timing order is sequential (1) or random (0) [default 0]
var optoEveryNthCycle% := 4;  'Sets opto timing to occur every Nth cycle [default 4]

' Sets output sequencer "DIGPS" command parameters (see Spike2 help index for more info on "DIGPS")
var digpsCycleCount%  := 4;  'Use 1 or 4 [default 4]
var digpsDuration%    := 2;  'Use 14 or 2 [default 2]
var digpsInterval%    := 4;  'Use 15 or 4 [default 4]

' Initialize global variables used other opto-related functions
var newChairPhase := chairPhase;
var newChairAngle := 0;
var delayLabels1%[1], delayLabels2%[1], delayArrLen%, prevStimNum%, halfCycle%, delayVal2%;
UpdateOptoParamsForSequencer();

' Compute number of sequencer steps for GAP1, GAP2, and GAP3 in the sequencer file
var halfgapSeqSteps, gap1SeqSteps, gap2SeqSteps, gap3SeqSteps;  'Initialize sequencer file variables
CalculateGapSeqSteps();
  
' Compute total experiment duration for settings window text information
var textStepPeriod%, textMinutes%;
var blockdurationTestGap      := gapDur + testBlockDuration;
var blockdurationTestTrainGap := gapDur + testBlockDuration + gapDur + trainBlockDuration;
var totalExperimentDuration   := (5.0 * blockdurationTestGap) + (1.0 * nTrainingBlocks% * blockdurationTestTrainGap);

' Initial block list generated from default parameter values
GenerateBlockList(nTestBlocks%, nTrainingBlocks%);

ToolbarStartup();


'--------------------------------------------------------------------------------
' PROTOCOL-SPECIFIC TOOLBAR FUNCTIONS
'--------------------------------------------------------------------------------

' Updates sampling window with protocol-specific configuration
Proc WindowUpdate()
    ChanShow("12..15");
    ChanHide("v1", "v2");
    HCursorNew(HTVELcom_ch%, 0.0);
    HCursorNew(HHVELcom_ch%, 0.0);
    'ChanHide("1,5,6,7,10", "v1", "v2", "14,15");
    SetOptoDelays();
End

Func ToolbarSineOn%()
    ' TODO: Implement regular sine on button
    return 1;
end

' Initializes and enables our toolbar functions
Proc ToolbarStartup()
    const initialDisabled%[] := {40}; 
    ToolbarClear();
    ToolbarSet(0, "Idle", ToolbarIdle%);
    ToolbarSet(1, "Quit", ToolbarQuit%);
    ToolbarSet(2, "New File", ToolbarNewFile%);
    ToolbarSet(3, "File Comments", ToolbarFileComments%);
    ToolbarSet(4, "Opto Settings", ToolbarOptoSettings%);
    ToolbarSet(5, "Expmt Settings", ToolbarExpmtSettings%);
    'TODO: ToolbarSet(9, "Sine On", ToolbarSineOn%);
    ToolbarSet(40, "Run Expmt", ToolbarRunExpmt%);
    ToolbarEnable(initialDisabled%, 0); 
    Toolbar("", 231);
End

Func ToolbarFileComments%()
    var ii%;
    DlgCreate("FILE COMMENTS", 0, 0, 79, 7);  'Initialize new dialog window
    DlgString(1, "Comment 1:", 2000, "", 17, 1);
    DlgString(2, "Comment 2:", 2000, "", 17, 2);
    DlgString(3, "Comment 3:", 2000, "", 17, 3);
    DlgString(4, "Comment 4:", 2000, "", 17, 4);
    DlgString(5, "Comment 5:", 2000, "", 17, 5);

    DlgAllow(0x3ff, ToolbarIdle%);  'Allow all, no idle
    DlgShow(fileComments$[0], fileComments$[1], fileComments$[2], fileComments$[3], fileComments$[4]);
    
    SetFileComments();
    return 1;
End

' Updates settings values whenever another value is changed
Func UpdateExpmtSettings%(item%) 
    var trainingType_value% := DlgValue(1);
    var nTrainingBlocks_value% := DlgValue(2);
    var trainBlockDuration_value := DlgValue(3);
    var nTestBlocks_value% := DlgValue(4);
    var testBlockDuration_value := DlgValue(5);
    var gapDur_value := DlgValue(6);
    var flashDur_value := DlgValue(7);
    var drumAmp_value := DlgValue(8);
    var drumFreq_value := DlgValue(9);
    var drumPhase_value := DlgValue(10);
    var chairAmp_value := DlgValue(11);
    var chairFreq_value := DlgValue(12);
    var chairPhase_value := DlgValue(13);
    DlgEnable(0, 9, 10, 12, 13);

    ' Ensure drumAmp and chairAmp are valid values for the training type
    if (trainingType_value% = 0) or (trainingType_value% = 1) then
        if (drumAmp_value = 0) or (chairAmp_value = 0) then
            Message("Zero deg/s is not a valid value for `opto stim` or `pretest only` experiments.\nVelocities wil be reset to default values.");
            drumAmp_value := -10.0;
            chairAmp_value := 10.0;
            DlgValue(8, drumAmp_value);
            DlgValue(11, chairAmp_value);
        endif;
    endif;

    docase
        case item% = 1 then
            docase
                case (trainingType_value% = 0) then
                    DlgValue(4, 1);
                    DlgValue(8, -10.0);
                    DlgValue(11, 10.0);
                case (trainingType_value% = 1) then
                    DlgValue(4, 3);
                    DlgValue(8, -10.0);
                    DlgValue(11, 10.0);
                case trainingType_value% = 2 then
                    DlgValue(8, 10.0);
                    DlgValue(11, 10.0);
                case trainingType_value% = 3 then
                    DlgValue(8, 0.0);
                    DlgValue(11, 10.0);
            endcase;
        case item% = 7 then
            if flashDur_value >= gapDur_value then
                Message("TTL flash duration must be less than Gap duration.");
                DlgValue(7, 0.1 * gapDur_value);
            endif;
        case item% = 8 then
            docase
                case (trainingType_value% = 0) or (trainingType_value% = 1) then
                    DlgValue(11, (-1) * (drumAmp_value / Abs(drumAmp_value)) * Abs(drumAmp_value));
                case trainingType_value% = 2 then
                    DlgValue(11, (drumAmp_value / Abs(drumAmp_value)) * Abs(drumAmp_value));
                case trainingType_value% = 3 then
                    DlgValue(8, 0.0);
            endcase;
        case item% = 11 then
            docase
                case (trainingType_value% = 0) or (trainingType_value% = 1) then
                    DlgValue(8, (-1) * (chairAmp_value / Abs(chairAmp_value)) * Abs(chairAmp_value));
                case trainingType_value% = 2 then
                    DlgValue(8, (chairAmp_value / Abs(chairAmp_value)) * Abs(chairAmp_value));
                case trainingType_value% = 3 then
                    DlgValue(8, 0.0);
            endcase;
    endcase;

    return 1;
End

' Settings window for modifying general experimental parameters
Func ToolbarExpmtSettings%()
    var width% := 85;
    DlgCreate("EXPERIMENT SETTINGS", 0, 0, width%, 13);  'Initialize new dialog window

    var col1box% := 31;
    var col1width% := col1box% + 12;
    DlgText("Training type:", 4, 2);
    DlgList(1, 20, "opto stim|pretest only", 9, col1box%-9, 2);
    DlgText("Number of train blocks:", 4, 3);
    DlgInteger(2, 11, 1, 99999, col1box%, 3, 0);
    DlgText("Train block duration (s):", 4, 4);
    DlgReal(3, 11, 0.001, 99999.0, col1box%, 4, 0);
    DlgText("Number of test blocks:", 4, 6);
    DlgInteger(4, 11, 1, 99999, col1box%, 6, 0);
    DlgText("Test block duration (s):", 4, 7);
    DlgReal(5, 11, 0.001, 99999.0, col1box%, 7, 0);
    DlgText("Gap block duration (s):|Total duration of each Gap block.", 4, 9);
    DlgReal(6, 11, 0.001, 100.0, col1box%, 9, 0);
    DlgText("Gap flash duration (s):|Duration of light flash in the middle of each Gap block.", 4, 10);
    DlgReal(7, 11, 0.000, 50.0, col1box%, 10, 0);

    ' Drum parameters boxes
    var col2txt% := col1width% + 6; 
    var col2box% := col2txt% + 21;
    var col2width% := 36;
    DlgText("Velocity (deg/s):", col2txt%, 2);
    DlgReal(8, 11, -50.0, 50.0, col2box%, 2, 0);
    DlgText("Frequency (Hz):", col2txt%, 3);
    DlgReal(9, 11, 0.1, 10.0, col2box%, 3, 0);
    DlgText("Phase (deg):", col2txt%, 4);
    DlgReal(10, 11, -360, 360, col2box%, 4, 0);

    ' Chair parameters boxes
    DlgText("Velocity (deg/s):", col2txt%, 7);
    DlgReal(11, 11, -50.0, 50.0, col2box%, 7, 0);
    DlgText("Frequency (Hz):", col2txt%, 8);
    DlgReal(12, 11, 0.1, 10.0, col2box%, 8, 0);
    DlgText("Phase (deg):", col2txt%, 9);
    DlgReal(13, 11, -360, 360, col2box%, 9, 0);
     
    DlgAllow(0x3ff, ToolbarIdle%, UpdateExpmtSettings%);  'Allow all, no idle, update settings function
    var gp1% := DlgGroup("General Parameters", 2, 1, col1width%, 10.5);
    var gp2% := DlgGroup("Drum Parameters", col2txt%-2, 1, col2width%, 4.5);
    var gp3% := DlgGroup("Chair Parameters", col2txt%-2, 6, col2width%, 4.5);

    DlgShow(trainingType%, nTrainingBlocks%, trainBlockDuration, nTestBlocks%, testBlockDuration, 
            gapDur, flashDur, drumAmp, drumFreq, drumPhase, chairAmp, chairFreq, chairPhase);

    ' Re-calculate number of test and train block cyles
    SetNumTestTrainCycles();

    ' Re-compute number of cycle steps for GAP1, GAP2, and GAP3 in sequencer file
    CalculateGapSeqSteps();

    ' Update opto stim parameters
    UpdateOptoParamsForSequencer();

    ' Re-generate the block list
    GenerateBlockList(nTestBlocks%, nTrainingBlocks%);

    ' Send new variable values to the sequencer
    SetSequencerValues();
    return 1;
End


' Updates settings values whenever another value is changed
Func UpdateOptoSettings%(item%)
    var temp_optoTrainingType% := DlgValue(1);
    var temp_optoTimingOrder% := DlgValue(2);
    var temp_optoEveryNthCycle% := DlgValue(3);
    var temp_digpsCycleCount% := DlgValue(4);
    var temp_digpsDuration% := DlgValue(5);
    var temp_digpsInterval% := DlgValue(6);

    docase
        case item% = 1 then
            DlgEnable(0, imageArr%);
            DlgEnable(1, imageArr%[temp_optoTrainingType%]);
            if temp_optoTrainingType% = 2 then
                DlgValue(3, 8);
            else
                DlgValue(3, 4);
            endif;
    endcase;

    return 1;
End

' Settings window for modifying opto-related parameters
Func ToolbarOptoSettings%()
    var width% := 121;
    DlgCreate("OPTO SETTINGS", 0, 0, width%, 21);  'Initialize new dialog window

    var col1box% := 23;
    var col1width% := col1box% + 23;
    DlgList(1, "Training type: ", "1Hz Doubles|0.5Hz Doubles|2Hz Doubles", 10, col1box%, 1);
    DlgList(2, "Timing order: ", "Random|Sequential", 7, col1box%, 2); 
    DlgText("Every Nth sine cycle:", 2, 3);
    DlgInteger(3, 5, 1, 16, col1box%, 3, 0);

    var col2txt% := col1width% + 8; 
    var col2box% := col2txt% + 19;
    DlgText("DIGPS cycle count:", col2txt%, 1);
    DlgInteger(4, 5, 1, 4, col2box%, 1, 0);
    DlgText("DIGPS duration:", col2txt%, 2);
    DlgInteger(5, 5, 2, 1000, col2box%, 2, 0);
    DlgText("DIGPS interval:", col2txt%, 3);
    DlgInteger(6, 5, 4, 1000, col2box%, 3, 0);
    
    imageArr%[2] := DlgImage(rootpath$+"/images/sine_2_hz_singles.jpg", 3, 5, -3, 15);
    imageArr%[1] := DlgImage(rootpath$+"/images/sine_0-5_hz_singles.jpg", 3, 5, -3, 15);
    imageArr%[0] := DlgImage(rootpath$+"/images/sine_1_hz_singles.jpg", 3, 5, -3, 15);

    DlgAllow(0x3ff, ToolbarIdle%, UpdateOptoSettings%);  'Allow all, no idle, update settings function

    DlgShow(optoTrainingType%, optoTimingOrder%, optoEveryNthCycle%, digpsCycleCount%, digpsDuration%, digpsInterval%);

    docase
        case (optoTrainingType% = 0) or (optoTrainingType% = 1) then
            drumFreq := 1;
            chairFreq := 1;
        case optoTrainingType% = 2 then
            drumFreq := 0.5;
            chairFreq := 0.5;
        case optoTrainingType% = 3 then
            drumFreq := 2;
            chairFreq := 2;
    endcase;

    ' Re-calculate number of test and train block cyles
    SetNumTestTrainCycles();

    ' Re-compute number of cycle steps for GAP1, GAP2, and GAP3 in sequencer file
    CalculateGapSeqSteps();

    UpdateOptoParamsForSequencer();
    SetOptoDelays();

    ' Send new variable values to the sequencer
    SetSequencerValues();
    return 1;
End

'--------------------------------------------------------------------------------
' COMPUTE NUMBER OF SEQUENCER STEPS FOR GAP1, GAP2, GAP3 IN SEQUENCER FILE
'--------------------------------------------------------------------------------
Proc CalculateGapSeqSteps()
    halfgapSeqSteps := (gapDur - flashDur) / 2.0;
    gap1SeqSteps := Round((halfgapSeqSteps * sampleRate / 3.0) - 2.0);
    gap2SeqSteps := Round((flashDur * sampleRate / 3.0));
    gap3SeqSteps := Round((halfgapSeqSteps * sampleRate / 3.0) - 1.0);
End


'--------------------------------------------------------------------------------
' GENERATE/UPDATE BLOCK LIST FOR A GIVEN NUMBER OF TRAINING BLOCKS
'--------------------------------------------------------------------------------
Proc GenerateBlockList(m%, n%)
    var i%, experimentTotalListLen%;
    var pretestList$[] := {"Gg", "Pp"};
    var trainingList$[] := {"Gg", "Tt"};
    var posttestList$[] := {"Gg", "Pp"};
    var pretestListLen% := Round(m%*Len(pretestList$[]));
    var trainingListLen% := Round(n%*Len(trainingList$[]));
    var posttestListLen% := Round(m%*Len(posttestList$[]));

    if trainingType% = 1 then
        experimentTotalListLen% := Round(pretestListLen%);
    else
        ' Compute total number of blocks for during training section and for the entire experiment
        experimentTotalListLen% := Round(pretestListLen% + posttestListLen% + trainingListLen%);
    endif;

    resize blockList$[experimentTotalListLen%];  'Resize blockList$[] array to the required size
    ' Reset all elements of the block list to empty string values
    for i% := 0 to experimentTotalListLen%-1 do
        blockList$[i%] := "";
    next;

    ' Populate array with blocks
    for i% := 0 to experimentTotalListLen%-1 step 2 do
        blockList$[i%] := "Gg";
        if (i% < pretestListLen%-1) or (i% > pretestListLen%+trainingListLen%-1) then
            blockList$[i%+1] := "Pp";
        else
            blockList$[i%+1] := "Tt";
        endif;
    next;

    ' Do a final check to make sure there are no consecutive duplicates
    for i% := 0 to experimentTotalListLen%-2 do
        if blockList$[i%] = blockList$[i%+1] then
            Message("[ERROR] Duplicate blocks found between elements %d and %d!", i%, i%+1);
            halt
        endif;
    next;

    ' Update nBlocks% with current number of total blocks
    nBlocks% := Len(blockList$[]);
    PrintLog("\nBlock list generated:  ", blockList$[], "\n");
End


'--------------------------------------------------------------------------------
' SEND CURRENT SPIKE2 VARIABLE VALUES TO SEQUENCER
'--------------------------------------------------------------------------------
Proc SetSequencerValues()
    ' Drum parameters
    SampleSeqVar(2, Amp2Int32%(drumVelocityOffset, drumVelocity2Voltage));  'DrumOff
    SampleSeqVar(3, Amp2Int16%(drumAmp, drumVelocity2Voltage));             'DrumAmp
    SampleSeqVar(4, Hz2Int32%(drumFreq));                                   'DrumFrq
    SampleSeqVar(5, Angle2Int32%(drumPhase));                               'DrumPhs
    SampleSeqVar(7, nDrumTestCycles%);                                      'NdrumP
    SampleSeqVar(8, nDrumTrainCycles%);                                     'NdrumT

    ' Chair parameters
    SampleSeqVar(10, Amp2Int32%(chairVelocityOffset, chairVelocity2Voltage));  'ChairOff
    SampleSeqVar(11, Amp2Int16%(chairAmp, chairVelocity2Voltage));             'ChairAmp
    SampleSeqVar(12, Hz2Int32%(chairFreq));                                    'ChairFrq
    SampleSeqVar(13, Angle2Int32%(newChairPhase));                             'ChairPhs
    SampleSeqVar(14, Angle2Int32%(newChairAngle));                             'ChairAng
    SampleSeqVar(15, nChairTestCycles%);                                       'NchairP
    SampleSeqVar(16, nChairTrainCycles%+1);                                    'NchairT

    ' Gap block parameters
    SampleSeqVar(18, gap1SeqSteps);  'Gap1Dur
    SampleSeqVar(19, gap2SeqSteps);  'FlashDur
    SampleSeqVar(20, gap3SeqSteps);  'Gap3Dur

    ' Opto stim parameters
    SampleSeqVar(22, delayArrLen%-1);      'NDelays
    SampleSeqVar(23, digpsDuration%);      'PulDur
    SampleSeqVar(24, digpsInterval%);      'PulInt
    SampleSeqVar(25, digpsCycleCount%);    'PulNCycl
    SampleSeqVar(26, optoEveryNthCycle%);  'EveryNth

    CheckDelayChange(); 
End

'--------------------------------------------------------------------------------
' CALCULATE LEFT AND RIGHT OPTO TIMING DELAYS TO SEND TO SEQUENCER
'--------------------------------------------------------------------------------
Proc SetOptoDelays()
    var tempBaseArrLen%, tempBaseArr%[1];
    var tempArrLen%, tempDelayArr1%[1], tempDelayArr2%[1];
    ' Get the base array of delay timings and its length
    docase
        case optoTrainingType% = 0 then  'For 1 hz singles
            tempBaseArrLen% := Len(delays1Hz%[]);
            resize tempBaseArr%[tempBaseArrLen%];
            ArrConst(tempBaseArr%[], delays1Hz%[]);
        case optoTrainingType% = 1 then  'For 0.5 hz singles
            tempBaseArrLen% := Len(delays0p5Hz%[]);
            resize tempBaseArr%[tempBaseArrLen%];
            ArrConst(tempBaseArr%[], delays0p5Hz%[]);
        case optoTrainingType% = 2 then  'For 2 hz singles
            tempBaseArrLen% := Len(delays2Hz%[]);
            resize tempBaseArr%[tempBaseArrLen%];
            ArrConst(tempBaseArr%[], delays2Hz%[]);
    endcase;

    ' Define values for quarter and half cycles
    var halfCycle := (chairFreq*sampleRate) / 2;
    var quarterCycle := halfCycle / 2;

    tempArrLen% := BinomialC(tempBaseArrLen%, 2) + 1;  'N choose 2 plus 1 for double NoStim
    resize tempDelayArr1%[tempArrLen%];
    resize tempDelayArr2%[tempArrLen%];
    var ii%, jj%, kk%, tempBaseVal1%, tempBaseVal2%;
    for ii% := 0 to tempBaseArrLen%-1 do
        tempBaseVal1% := tempBaseArr%[ii%];
        for jj% := (ii%+1) to tempBaseArrLen%-1 do
            tempBaseVal2% := tempBaseArr%[jj%];
            tempDelayArr1%[kk%] := tempBaseVal1%;
            tempDelayArr2%[kk%] := tempBaseVal2%;
            kk% := kk% + 1;
        next;    
    next;
    tempDelayArr1%[kk%] := -1;
    tempDelayArr2%[kk%] := -1;

    ' Duration (s) per repeat of the set of array delay timing values
    var durationPerArrRepeat := tempArrLen% * optoEveryNthCycle% * chairFreq; 
    
    ' Number of times base array can be repeated within approx. desired training block duration
    var nrepeats% := Round(trainBlockDuration / durationPerArrRepeat);
    
    ' Actual resulting duration of the training block
    var trainBlockDurationActual := durationPerArrRepeat * nrepeats%;

    ' Initialize arrays to store delay timing values over an entire training block
    delayArrLen% := Round(tempArrLen%*nrepeats%);
    resize delayLabels1%[delayArrLen%];
    resize delayLabels2%[delayArrLen%];
    var baseDelays1%[delayArrLen%], baseDelays2%[delayArrLen%];

    ' Delay arrays are now split up into the four pulses per stimulus cycle
    var delayValuesA%[delayArrLen%], delayValuesB%[delayArrLen%];
    var delayValuesC%[delayArrLen%], delayValuesD%[delayArrLen%];
    var delayChannelsA%[delayArrLen%], delayChannelsB%[delayArrLen%];
    var delayChannelsC%[delayArrLen%], delayChannelsD%[delayArrLen%];

    ' Define necessary adjustment shifts to correct for opto timings
    ' Note that the first opto pulse should not need any adjustment
    var shiftA% := 6;
    var shiftB% := 12;
    var shiftC% := 10;
    var shiftD% := 8;

    ' Populate the arrays
    var delay1_jj%, delay2_jj%;
    var delay1_1_jj%, delay1_2_jj%, delay2_1_jj%, delay2_2_jj%;
    var delayCh1_1_jj%, delayCh1_2_jj%, delayCh2_1_jj%, delayCh2_2_jj%;
    kk% := 0;
    for ii% := 0 to nrepeats%-1 do
        ' Shuffle array if random timing order is selected in settings
        if optoTimingOrder% = 0 then
            ArrSort(tempDelayArr1%[], -1, tempDelayArr2%[]);
        endif;
        ' Loop through each base delay value
        for jj% := 0 to tempArrLen%-1 do 
            delay1_jj% := tempDelayArr1%[jj%];  'Base delay value 1
            delay2_jj% := tempDelayArr2%[jj%];  'Base delay value 2
            baseDelays1%[kk%] := delay1_jj%;
            baseDelays2%[kk%] := delay2_jj%;
        
            ' Set delay and channel values for each half-cycle of stimulus
            if (delay1_jj% < Round(halfCycle)) then
                delay1_1_jj% := delay1_jj%;
                delay1_2_jj% := Round(delay1_jj% + halfCycle);
                delayCh1_1_jj% := 3;
                delayCh1_2_jj% := 4;
            else
                delay1_1_jj% := Round(delay1_jj% - halfCycle);
                delay1_2_jj% := delay1_jj%;
                delayCh1_1_jj% := 4;
                delayCh1_2_jj% := 3;
            endif;
            
            if (delay2_jj% < Round(halfCycle)) then
                delay2_1_jj% := delay2_jj%;
                delay2_2_jj% := Round(delay2_jj% + halfCycle);
                delayCh2_1_jj% := 3;
                delayCh2_2_jj% := 4;
            else
                delay2_1_jj% := Round(delay2_jj% - halfCycle);
                delay2_2_jj% := delay2_jj%;
                delayCh2_1_jj% := 4;
                delayCh2_2_jj% := 3;
            endif;
        
            ' Set desired behaviour for the case of each possible combination
            docase
                case (delay1_1_jj% = -1) and (delay2_1_jj% = -1) then
                    ' Case when delay1 and delay2 are both NoStim
                    delayValuesA%[kk%] := -1;
                    delayValuesB%[kk%] := -1;
                    delayValuesC%[kk%] := -1;
                    delayValuesD%[kk%] := -1;
                case (delay1_1_jj% = -1) and (delay2_1_jj% <> -1) then
                    ' Case when delay1 is NoStim but delay2 is not
                    delayValuesA%[kk%] := delay2_1_jj% + shiftA%;
                    delayValuesB%[kk%] := -1;
                    delayValuesC%[kk%] := Round(halfCycle - shiftB%);
                    delayValuesD%[kk%] := -1;
                    delayChannelsA%[kk%] := delayCh2_1_jj%;
                    delayChannelsC%[kk%] := delayCh2_2_jj%;
                case (delay1_1_jj% <> -1) and (delay2_1_jj% = -1) then
                    ' Case when delay2 is NoStim but delay1 is not
                    delayValuesA%[kk%] := delay1_1_jj% + shiftA%;
                    delayValuesB%[kk%] := -1;
                    delayValuesC%[kk%] := Round(halfCycle - shiftB%);
                    delayValuesD%[kk%] := -1;
                    delayChannelsA%[kk%] := delayCh1_1_jj%;
                    delayChannelsC%[kk%] := delayCh1_2_jj%;
                case (delay1_1_jj% = delay2_1_jj%) and (delayCh1_1_jj% = delayCh2_1_jj%) then
                    ' Case when delay1 and delay2 have the exact same value and channel
                    ' Note the result is the same as the previous case
                    delayValuesA%[kk%] := delay1_1_jj% + shiftA%;
                    delayValuesB%[kk%] := -1;
                    delayValuesC%[kk%] := Round(halfCycle - shiftB%);
                    delayValuesD%[kk%] := -1;
                    delayChannelsA%[kk%] := delayCh1_1_jj%;
                    delayChannelsC%[kk%] := delayCh1_2_jj%;
                case (delay1_1_jj% = delay2_1_jj%) and (delayCh1_1_jj% <> delayCh2_1_jj%) then
                    ' Case when delay1 and delay2 have the same value but not channel
                    delayValuesA%[kk%] := delay1_1_jj% + shiftA%;
                    delayValuesB%[kk%] := 0;
                    delayValuesC%[kk%] := Round(halfCycle - shiftB%);
                    delayValuesD%[kk%] := 0;
                    delayChannelsA%[kk%] := delayCh1_1_jj%;
                    delayChannelsB%[kk%] := delayCh2_1_jj%;
                    delayChannelsC%[kk%] := delayCh1_2_jj%;
                    delayChannelsD%[kk%] := delayCh2_2_jj%;
                case (delay1_1_jj% < delay2_1_jj%) then
                    ' Case when delay1 needs to comes before delay2
                    delayValuesA%[kk%] := delay1_1_jj% + shiftA%;
                    delayValuesB%[kk%] := Round(delay2_1_jj% - delay1_1_jj% - shiftB%);
                    delayValuesC%[kk%] := Round(delay1_2_jj% - delay2_1_jj% - shiftC%);
                    delayValuesD%[kk%] := Round(delay2_2_jj% - delay1_2_jj% - shiftD%);
                    delayChannelsA%[kk%] := delayCh1_1_jj%;
                    delayChannelsB%[kk%] := delayCh2_1_jj%;
                    delayChannelsC%[kk%] := delayCh1_2_jj%;
                    delayChannelsD%[kk%] := delayCh2_2_jj%;
                case (delay1_1_jj% > delay2_1_jj%) then
                    ' Case when delay2 needs to comes before delay1
                    delayValuesA%[kk%] := delay2_1_jj% + shiftA%;
                    delayValuesB%[kk%] := Round(delay1_1_jj% - delay2_1_jj% - shiftB%);
                    delayValuesC%[kk%] := Round(delay2_2_jj% - delay1_1_jj% - shiftC%);
                    delayValuesD%[kk%] := Round(delay1_2_jj% - delay2_2_jj% - shiftD%);
                    delayChannelsA%[kk%] := delayCh2_1_jj%;
                    delayChannelsB%[kk%] := delayCh1_1_jj%;
                    delayChannelsC%[kk%] := delayCh2_2_jj%;
                    delayChannelsD%[kk%] := delayCh1_2_jj%;
            endcase
        
            ' Populate the label arrays
            if delay1_jj% = -1 then
                delayLabels1%[kk%] := -1;
            else
                delayLabels1%[kk%] := Round(delay1_jj% - quarterCycle);
            endif;

            if delay2_jj% = -1 then
                delayLabels2%[kk%] := -1;
            else
                delayLabels2%[kk%] := Round(delay2_jj% - quarterCycle);
            endif;

            kk% := kk% + 1;
        next;
    next;

    PrintLog("Actual training block duration: %g s\n", trainBlockDurationActual);
    PrintLog("Delay timings per set: %d\n", tempArrLen%);
    PrintLog("Number of repeats of array set: %d\n", nrepeats%);
    PrintLog("\nbase delays: ", tempBaseArr%[]);
    PrintLog("Labels1: ", delayLabels1%[]);
    PrintLog("Labels2: ", delayLabels2%[], "\n");
    PrintLog("baseDelays1: ", baseDelays1%[]);
    PrintLog("baseDelays2: ", baseDelays2%[], "\n");
    PrintLog("delayValuesA%: ", delayValuesA%[]);
    PrintLog("delayChannelsA%: ", delayChannelsA%[], "\n");
    PrintLog("delayValuesB%: ", delayValuesB%[]);
    PrintLog("delayChannelsB%: ", delayChannelsB%[], "\n");
    PrintLog("delayValuesC%: ", delayValuesC%[]);
    PrintLog("delayChannelsC%: ", delayChannelsC%[], "\n");
    PrintLog("delayValuesD%: ", delayValuesD%[]);
    PrintLog("delayChannelsD%: ", delayChannelsD%[], "\n");

    SampleSeqTable(delayValuesA%[], 0);
    SampleSeqTable(delayChannelsA%[], 5000);
    SampleSeqTable(delayValuesB%[], 10000);
    SampleSeqTable(delayChannelsB%[], 15000);
    SampleSeqTable(delayValuesC%[], 20000);
    SampleSeqTable(delayChannelsC%[], 25000);
    SampleSeqTable(delayValuesD%[], 30000);
    SampleSeqTable(delayChannelsD%[], 35000);
End

Proc CheckDelayChange()
    var currStimNum% := SampleSeqVar(36); 'Current StimNum from sequencer
    var currDelayLabel1%, currDelayLabel2%, smpltxt1$, smpltxt2$;
    if (currStimNum% > 0) and (currStimNum% <> prevStimNum%) then
        currDelayLabel1% := delayLabels1%[currStimNum%-1];
        currDelayLabel2% := delayLabels2%[currStimNum%-1];
        if currDelayLabel1% = -1 then
            smpltxt1$ := "NoStim";
        else
            smpltxt1$ := Str$(currDelayLabel1%)+"ms";
        endif;
        if currDelayLabel2% = -1 then
            smpltxt2$ := "NoStim";
        else
            smpltxt2$ := Str$(currDelayLabel2%)+"ms";
        endif;
        SampleText("("+smpltxt1$+","+smpltxt2$+")", -1, 1);
        prevStimNum% := currStimNum%;
    endif;
End

Proc UpdateOptoParamsForSequencer()
    if digpsInterval% <= digpsDuration% then
        digpsInterval% := digpsDuration% + 1;
    endif;

    var pulseGap%;
    if digpsCycleCount% > 1 then
        pulseGap% := Round(digpsInterval% - digpsDuration%);
    else
        pulseGap% := 0;
    endif;

    optoDuration% := Round((digpsInterval% * digpsCycleCount%) - pulseGap%);
    ' The added value can be adjusted to fine-tune the timing of 1st stim
    var offsetPhaseAngle% := Round(((optoDuration%/2) + 22) * 360 / sampleRate);
    newChairPhase := chairPhase - offsetPhaseAngle%;
    newChairAngle := 1.0 * offsetPhaseAngle%;
End

Func AddTextMark(samplekey$, blocknumber%)
    ' Search Index "Marker codes, Colour for" for more info on marker code colors
    var text$, code%;
    docase
        case samplekey$ = "G" then
            text$ := "GAP";
            code% := 1;
        case samplekey$ = "P" then
            if blockNum% <= Round(2*nTestBlocks%) then
                pretestBlockNum% := pretestBlockNum% + 1;
                text$ := "PRE#"+Str$(pretestBlockNum%);
                code% := 2;
                
            else
                posttestBlockNum% := posttestBlockNum% + 1;
                text$ := "POST#"+Str$(posttestBlockNum%);
                code% := 8;
                
            endif;
        case samplekey$ = "T" then
            trainBlockNum% := trainBlockNum% + 1;
            text$ := "TRAIN#"+Str$(trainBlockNum%);
            code% := 4;
    endcase;
    return SampleText(text$, -1, code%); 
End
