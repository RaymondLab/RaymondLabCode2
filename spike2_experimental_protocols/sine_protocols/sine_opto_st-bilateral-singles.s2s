' ------------------------------------------------------------------------------
' SINE - SINGLE TRIAL OPTOSTIM EXPERIMENTAL PROTOCOL (REQUIRES SPIKE2 VERSION 10)
'
' Values for local (rig-specific) variables are stored in the system registry: 
' HKEY_CURRENT_USER\Software\CED\Spike2\RigParams
' 
' ------------------------------------------------------------------------------

' Set the sequencer file to use for the protocol
const sequencerFile$ := "sine_protocols/sine_opto_st-bilateral-singles.pls";

' This file is the same for all SINE protocols
#include "sine_core.s2s"

' Overwrite the default parameter values with protocol-specific values
nTestBlocks%       := 3;     'Number of pretest/posttest blocks [default 3]
testBlockDuration  := 45;    'Duration (s) of each pretest/posttest block [default 45.0]
nTrainingBlocks%   := 1;     'Number of training blocks [default 1]
trainBlockDuration := 1800;  'Duration (s) of each training block [default 1800.0]

' Re-calculate number of test and train block cyles
SetNumTestTrainCycles();

' Define the base opto timing delays for each experiment type ("-1" corresponds to "no stim")
const delays0p5Hz%[] := {0, 125, 250, 375, 500, 625, 750, 875, 1000, 1125, 1250, 1375, 1500, 1625, 1750, 1875, -1};
const delays1Hz%[]   := {0, 125, 188, 250, 313, 375, 500, 625, 750, 875, -1};
const delays2Hz%[]   := {0, 63, 125, 188, 250, 313, 375, 438, -1};

' "Opto Settings" default parameters
var imageArr%[3], optoDuration%;
var optoTrainingType%  := 0;  'Defines the frequency of the training for opto experiments [default 0]
var optoTimingOrder%   := 0;  'Defines whether timing order is sequential or random [default 0]
var optoEveryNthCycle% := 4;  'Sets opto timing to occur every Nth cycle [default 4]

' Sets output sequencer "DIGPS" command parameters (see Spike2 help index for more info on "DIGPS")
var digpsCycleCount%  := 4;  'Use 1 or 4 [default 4]
var digpsDuration%    := 2;  'Use 14 or 2 [default 2]
var digpsInterval%    := 4;  'Use 15 or 4 [default 4]

' Sequencer timing overhead constants for Approach 1 (derived from instruction counting)
' These can be fine-tuned using the one-time calibration procedure described below:
'   1. Set up 1 Hz chair sine (standard phase), trigger pulse at delay=250 ms (peak velocity)
'   2. Record cosine command (DAC 1) and digital output
'   3. Measure time from cosine peak to burst center
'   4. Difference from expected (0 ms) = fixedOverhead to use here
var seqFixedOverhead%  := 16;    'WAITC to burst center: 4(pre) + 5(post) + 7(burstCenter)
var seqInterOverhead%  := 4;     'first DIGPC to second DIGPC: DIGPS(3) + DIGPC(1)
var delayLabels%[1], delayArrLen%, prevStimNum%, delayVal2%;
UpdateOptoParamsForSequencer();

' Compute number of sequencer steps for GAP1, GAP2, and GAP3 in the sequencer file
var halfgapSeqSteps, gap1SeqSteps, gap2SeqSteps, gap3SeqSteps;  'Initialize sequencer file variables
CalculateGapSeqSteps();
  
' Compute total experiment duration for settings window text information
var textStepPeriod%, textMinutes%;
var blockdurationTestGap      := gapDur + testBlockDuration;
var blockdurationTestTrainGap := gapDur + testBlockDuration + gapDur + trainBlockDuration;
var totalExperimentDuration   := (5.0 * blockdurationTestGap) + (1.0 * nTrainingBlocks% * blockdurationTestTrainGap);

' Initial block list generated from default parameter values
GenerateBlockList(nTestBlocks%, nTrainingBlocks%);

ToolbarStartup();


'--------------------------------------------------------------------------------
' PROTOCOL-SPECIFIC TOOLBAR FUNCTIONS
'--------------------------------------------------------------------------------

' Updates sampling window with protocol-specific configuration
Proc WindowUpdate()
    ChanShow("12..15");
    ChanHide("v1", "v2");
    HCursorNew(HTVELcom_ch%, 0.0);
    HCursorNew(HHVELcom_ch%, 0.0);
    'ChanHide("1,5,6,7,10", "v1", "v2", "14,15");
    SetOptoDelays();
End

Func ToolbarSineOn%()
    ' TODO: Implement regular sine on button
    return 1;
end

' Initializes and enables our toolbar functions
Proc ToolbarStartup()
    const initialDisabled%[] := {40}; 
    ToolbarClear();
    ToolbarSet(0, "Idle", ToolbarIdle%);
    ToolbarSet(1, "Quit", ToolbarQuit%);
    ToolbarSet(2, "New File", ToolbarNewFile%);
    ToolbarSet(3, "File Comments", ToolbarFileComments%);
    ToolbarSet(4, "Opto Settings", ToolbarOptoSettings%);
    ToolbarSet(5, "Expmt Settings", ToolbarExpmtSettings%);
    'TODO: ToolbarSet(9, "Sine On", ToolbarSineOn%);
    ToolbarSet(40, "Run Expmt", ToolbarRunExpmt%);
    ToolbarEnable(initialDisabled%, 0); 
    Toolbar("", 231);
End

Func ToolbarFileComments%()
    var ii%;
    DlgCreate("FILE COMMENTS", 0, 0, 79, 7);  'Initialize new dialog window
    DlgString(1, "Comment 1:", 2000, "", 17, 1);
    DlgString(2, "Comment 2:", 2000, "", 17, 2);
    DlgString(3, "Comment 3:", 2000, "", 17, 3);
    DlgString(4, "Comment 4:", 2000, "", 17, 4);
    DlgString(5, "Comment 5:", 2000, "", 17, 5);

    DlgAllow(0x3ff, ToolbarIdle%);  'Allow all, no idle
    DlgShow(fileComments$[0], fileComments$[1], fileComments$[2], fileComments$[3], fileComments$[4]);
    
    SetFileComments();
    return 1;
End

' Updates settings values whenever another value is changed
Func UpdateExpmtSettings%(item%) 
    var trainingType_value% := DlgValue(1);
    var nTrainingBlocks_value% := DlgValue(2);
    var trainBlockDuration_value := DlgValue(3);
    var nTestBlocks_value% := DlgValue(4);
    var testBlockDuration_value := DlgValue(5);
    var gapDur_value := DlgValue(6);
    var flashDur_value := DlgValue(7);
    var drumAmp_value := DlgValue(8);
    var drumFreq_value := DlgValue(9);
    var drumPhase_value := DlgValue(10);
    var chairAmp_value := DlgValue(11);
    var chairFreq_value := DlgValue(12);
    var chairPhase_value := DlgValue(13);
    DlgEnable(0, 9, 10, 12, 13);

    ' Ensure drumAmp and chairAmp are valid values for the training type
    if (trainingType_value% = 0) or (trainingType_value% = 1) then
        if (drumAmp_value = 0) or (chairAmp_value = 0) then
            Message("Zero deg/s is not a valid value for `opto stim` or `pretest only` experiments.\nVelocities wil be reset to default values.");
            drumAmp_value := -10.0;
            chairAmp_value := 10.0;
            DlgValue(8, drumAmp_value);
            DlgValue(11, chairAmp_value);
        endif;
    endif;

    docase
        case item% = 7 then
            if flashDur_value >= gapDur_value then
                Message("TTL flash duration must be less than Gap duration.");
                DlgValue(7, 0.1 * gapDur_value);
            endif;
        case item% = 8 then
            docase
                case (trainingType_value% = 0) or (trainingType_value% = 1) then
                    DlgValue(11, (-1) * (drumAmp_value / Abs(drumAmp_value)) * Abs(drumAmp_value));
                case trainingType_value% = 2 then
                    DlgValue(11, (drumAmp_value / Abs(drumAmp_value)) * Abs(drumAmp_value));
                case trainingType_value% = 3 then
                    DlgValue(8, 0.0);
            endcase;
        case item% = 11 then
            docase
                case (trainingType_value% = 0) or (trainingType_value% = 1) then
                    DlgValue(8, (-1) * (chairAmp_value / Abs(chairAmp_value)) * Abs(chairAmp_value));
                case trainingType_value% = 2 then
                    DlgValue(8, (chairAmp_value / Abs(chairAmp_value)) * Abs(chairAmp_value));
                case trainingType_value% = 3 then
                    DlgValue(8, 0.0);
            endcase;
    endcase;

    return 1;
End

' Settings window for modifying general experimental parameters
Func ToolbarExpmtSettings%()
    var width% := 85;
    DlgCreate("EXPERIMENT SETTINGS", 0, 0, width%, 13);  'Initialize new dialog window

    var col1box% := 31;
    var col1width% := col1box% + 12;
    DlgText("Training type:", 4, 2);
    DlgList(1, 20, "opto stim|pretest only", 9, col1box%-9, 2);
    DlgText("Number of train blocks:", 4, 3);
    DlgInteger(2, 11, 1, 99999, col1box%, 3, 0);
    DlgText("Train block duration (s):", 4, 4);
    DlgReal(3, 11, 0.001, 99999.0, col1box%, 4, 0);
    DlgText("Number of test blocks:", 4, 6);
    DlgInteger(4, 11, 1, 99999, col1box%, 6, 0);
    DlgText("Test block duration (s):", 4, 7);
    DlgReal(5, 11, 0.001, 99999.0, col1box%, 7, 0);
    DlgText("Gap block duration (s):|Total duration of each Gap block.", 4, 9);
    DlgReal(6, 11, 0.001, 100.0, col1box%, 9, 0);
    DlgText("Gap flash duration (s):|Duration of light flash in the middle of each Gap block.", 4, 10);
    DlgReal(7, 11, 0.000, 50.0, col1box%, 10, 0);

    ' Drum parameters boxes
    var col2txt% := col1width% + 6; 
    var col2box% := col2txt% + 21;
    var col2width% := 36;
    DlgText("Velocity (deg/s):", col2txt%, 2);
    DlgReal(8, 11, -50.0, 50.0, col2box%, 2, 0);
    DlgText("Frequency (Hz):", col2txt%, 3);
    DlgReal(9, 11, 0.1, 10.0, col2box%, 3, 0);
    DlgText("Phase (deg):", col2txt%, 4);
    DlgReal(10, 11, -360, 360, col2box%, 4, 0);

    ' Chair parameters boxes
    DlgText("Velocity (deg/s):", col2txt%, 7);
    DlgReal(11, 11, -50.0, 50.0, col2box%, 7, 0);
    DlgText("Frequency (Hz):", col2txt%, 8);
    DlgReal(12, 11, 0.1, 10.0, col2box%, 8, 0);
    DlgText("Phase (deg):", col2txt%, 9);
    DlgReal(13, 11, -360, 360, col2box%, 9, 0);
     
    DlgAllow(0x3ff, ToolbarIdle%, UpdateExpmtSettings%);  'Allow all, no idle, update settings function
    var gp1% := DlgGroup("General Parameters", 2, 1, col1width%, 10.5);
    var gp2% := DlgGroup("Drum Parameters", col2txt%-2, 1, col2width%, 4.5);
    var gp3% := DlgGroup("Chair Parameters", col2txt%-2, 6, col2width%, 4.5);

    DlgShow(trainingType%, nTrainingBlocks%, trainBlockDuration, nTestBlocks%, testBlockDuration, 
            gapDur, flashDur, drumAmp, drumFreq, drumPhase, chairAmp, chairFreq, chairPhase);

    ' Re-calculate number of test and train block cyles
    SetNumTestTrainCycles();

    ' Re-compute number of cycle steps for GAP1, GAP2, and GAP3 in sequencer file
    CalculateGapSeqSteps();

    ' Update opto stim parameters
    UpdateOptoParamsForSequencer();

    ' Re-generate the block list
    GenerateBlockList(nTestBlocks%, nTrainingBlocks%);

    ' Send new variable values to the sequencer
    SetSequencerValues();
    return 1;
End


' Updates settings values whenever another value is changed
Func UpdateOptoSettings%(item%)
    var temp_optoTrainingType% := DlgValue(1);
    var temp_optoTimingOrder% := DlgValue(2);
    var temp_optoEveryNthCycle% := DlgValue(3);
    var temp_digpsCycleCount% := DlgValue(4);
    var temp_digpsDuration% := DlgValue(5);
    var temp_digpsInterval% := DlgValue(6);

    docase
        case item% = 1 then
            DlgEnable(0, imageArr%);
            DlgEnable(1, imageArr%[temp_optoTrainingType%]);
            if temp_optoTrainingType% = 2 then
                DlgValue(3, 8);
            else
                DlgValue(3, 4);
            endif;
    endcase;

    return 1;
End

' Settings window for modifying opto-related parameters
Func ToolbarOptoSettings%()
    var width% := 121;
    DlgCreate("OPTO SETTINGS", 0, 0, width%, 21);  'Initialize new dialog window

    var col1box% := 23;
    var col1width% := col1box% + 23;
    DlgList(1, "Training type: ", "1Hz Singles|0.5Hz Singles|2Hz Singles", 10, col1box%, 1);
    DlgList(2, "Timing order: ", "Random|Sequential", 7, col1box%, 2); 
    DlgText("Every Nth sine cycle:", 2, 3);
    DlgInteger(3, 5, 1, 16, col1box%, 3, 0);

    var col2txt% := col1width% + 8; 
    var col2box% := col2txt% + 19;
    DlgText("DIGPS cycle count:", col2txt%, 1);
    DlgInteger(4, 5, 1, 4, col2box%, 1, 0);
    DlgText("DIGPS duration:", col2txt%, 2);
    DlgInteger(5, 5, 2, 1000, col2box%, 2, 0);
    DlgText("DIGPS interval:", col2txt%, 3);
    DlgInteger(6, 5, 4, 1000, col2box%, 3, 0);
    
    imageArr%[2] := DlgImage(rootpath$+"/images/sine_2_hz_singles.jpg", 3, 5, -3, 15);
    imageArr%[1] := DlgImage(rootpath$+"/images/sine_0-5_hz_singles.jpg", 3, 5, -3, 15);
    imageArr%[0] := DlgImage(rootpath$+"/images/sine_1_hz_singles.jpg", 3, 5, -3, 15);

    DlgAllow(0x3ff, ToolbarIdle%, UpdateOptoSettings%);  'Allow all, no idle, update settings function

    DlgShow(optoTrainingType%, optoTimingOrder%, optoEveryNthCycle%, digpsCycleCount%, digpsDuration%, digpsInterval%);

    docase
        case optoTrainingType% = 0 then
            drumFreq := 1;
            chairFreq := 1;
        case optoTrainingType% = 1 then
            drumFreq := 0.5;
            chairFreq := 0.5;
        case optoTrainingType% = 2 then
            drumFreq := 2;
            chairFreq := 2;
    endcase;
    drumPeriod := 1/drumFreq;
    chairPeriod := 1/chairFreq;

    ' Re-calculate number of test and train block cyles
    SetNumTestTrainCycles();

    ' Re-compute number of cycle steps for GAP1, GAP2, and GAP3 in sequencer file
    CalculateGapSeqSteps();

    UpdateOptoParamsForSequencer();
    SetOptoDelays();

    ' Send new variable values to the sequencer
    SetSequencerValues();
    return 1;
End

'--------------------------------------------------------------------------------
' COMPUTE NUMBER OF SEQUENCER STEPS FOR GAP1, GAP2, GAP3 IN SEQUENCER FILE
'--------------------------------------------------------------------------------
Proc CalculateGapSeqSteps()
    halfgapSeqSteps := (gapDur - flashDur) / 2.0;
    gap1SeqSteps := Round((halfgapSeqSteps * sampleRate / 3.0) - 2.0);
    gap2SeqSteps := Round((flashDur * sampleRate / 3.0));
    gap3SeqSteps := Round((halfgapSeqSteps * sampleRate / 3.0) - 1.0);
End


'--------------------------------------------------------------------------------
' GENERATE/UPDATE BLOCK LIST FOR A GIVEN NUMBER OF TRAINING BLOCKS
'--------------------------------------------------------------------------------
Proc GenerateBlockList(m%, n%)
    var i%, experimentTotalListLen%;
    var pretestList$[] := {"Gg", "Pp"};
    var trainingList$[] := {"Gg", "Tt"};
    var posttestList$[] := {"Gg", "Pp"};
    var pretestListLen% := Round(m%*Len(pretestList$[]));
    var trainingListLen% := Round(n%*Len(trainingList$[]));
    var posttestListLen% := Round(m%*Len(posttestList$[]));

    if trainingType% = 1 then
        experimentTotalListLen% := Round(pretestListLen%);
    else
        ' Compute total number of blocks for during training section and for the entire experiment
        experimentTotalListLen% := Round(pretestListLen% + posttestListLen% + trainingListLen%);
    endif;

    resize blockList$[experimentTotalListLen%];  'Resize blockList$[] array to the required size
    ' Reset all elements of the block list to empty string values
    for i% := 0 to experimentTotalListLen%-1 do
        blockList$[i%] := "";
    next;

    ' Populate array with blocks
    for i% := 0 to experimentTotalListLen%-1 step 2 do
        blockList$[i%] := "Gg";
        if (i% < pretestListLen%-1) or (i% > pretestListLen%+trainingListLen%-1) then
            blockList$[i%+1] := "Pp";
        else
            blockList$[i%+1] := "Tt";
        endif;
    next;

    ' Do a final check to make sure there are no consecutive duplicates
    for i% := 0 to experimentTotalListLen%-2 do
        if blockList$[i%] = blockList$[i%+1] then
            Message("[ERROR] Duplicate blocks found between elements %d and %d!", i%, i%+1);
            halt
        endif;
    next;

    ' Update nBlocks% with current number of total blocks
    nBlocks% := Len(blockList$[]);
    PrintLog("\nBlock list generated:  ", blockList$[], "\n");
End


'--------------------------------------------------------------------------------
' SEND CURRENT SPIKE2 VARIABLE VALUES TO SEQUENCER
'--------------------------------------------------------------------------------
Proc SetSequencerValues()
    ' Drum parameters
    SampleSeqVar(2, Amp2Int32%(drumVelocityOffset, drumVelocity2Voltage));  'DrumOff
    SampleSeqVar(3, Amp2Int16%(drumAmp, drumVelocity2Voltage));             'DrumAmp
    SampleSeqVar(4, Hz2Int32%(drumFreq));                                   'DrumFrq
    SampleSeqVar(5, Angle2Int32%(drumPhase));                               'DrumPhs
    SampleSeqVar(7, nDrumTestCycles%);                                      'NdrumP
    SampleSeqVar(8, nDrumTrainCycles%);                                     'NdrumT

    ' Chair parameters
    SampleSeqVar(10, Amp2Int32%(chairVelocityOffset, chairVelocity2Voltage));  'ChairOff
    SampleSeqVar(11, Amp2Int16%(chairAmp, chairVelocity2Voltage));             'ChairAmp
    SampleSeqVar(12, Hz2Int32%(chairFreq));                                    'ChairFrq
    SampleSeqVar(13, Angle2Int32%(chairPhase));                                'ChairPhs (standard, no shift)
    SampleSeqVar(14, Angle2Int32%(0));                                         'ChairAng (zero, no shift)
    SampleSeqVar(15, nChairTestCycles%);                                       'NchairP
    SampleSeqVar(16, nChairTrainCycles%+1);                                    'NchairT

    ' Gap block parameters
    SampleSeqVar(18, gap1SeqSteps);  'Gap1Dur
    SampleSeqVar(19, gap2SeqSteps);  'FlashDur
    SampleSeqVar(20, gap3SeqSteps);  'Gap3Dur

    ' Opto stim parameters
    SampleSeqVar(22, delayArrLen%-1);           'NDelays
    SampleSeqVar(23, digpsDuration%);           'PulDur
    SampleSeqVar(24, digpsInterval%);           'PulInt
    SampleSeqVar(25, digpsCycleCount%);         'PulNCycl
    SampleSeqVar(26, optoEveryNthCycle% - 1);   'EveryNth (minus 1 for Approach 1)
    SampleSeqVar(30, delayVal2%);               'DelVal2

    CheckDelayChange(); 
End

'--------------------------------------------------------------------------------
' CALCULATE LEFT AND RIGHT OPTO TIMING DELAYS TO SEND TO SEQUENCER
' Uses Approach 1: DELAY from previous cycle (no phase shift needed)
'   DelVal1 = target + period - seqFixedOverhead (adjusted delay for 1st hemisphere)
'   DelCh1 = 3 (ch2 first) or 4 (ch3 first) depending on target half-cycle
'   DelVal2 = halfCycle - seqInterOverhead (constant inter-hemisphere delay)
'--------------------------------------------------------------------------------
Proc SetOptoDelays()
    var tempArrLen%, tempDelayArr%[1];
    ' Get the base array of delay timings and its length
    docase
        case optoTrainingType% = 0 then  'For 1 hz singles
            tempArrLen% := Len(delays1Hz%[]);
            resize tempDelayArr%[tempArrLen%];
            ArrConst(tempDelayArr%[], delays1Hz%[]);
        case optoTrainingType% = 1 then  'For 0.5 hz singles
            tempArrLen% := Len(delays0p5Hz%[]);
            resize tempDelayArr%[tempArrLen%];
            ArrConst(tempDelayArr%[], delays0p5Hz%[]);
        case optoTrainingType% = 2 then  'For 2 hz singles
            tempArrLen% := Len(delays2Hz%[]);
            resize tempDelayArr%[tempArrLen%];
            ArrConst(tempDelayArr%[], delays2Hz%[]);
    endcase;

    ' Duration (s) per repeat of the set of array delay timing values
    var durationPerArrRepeat := tempArrLen% * optoEveryNthCycle% * chairFreq; 
    
    ' Number of times base array can be repeated within approx. desired training block duration
    var nrepeats% := Round(trainBlockDuration / durationPerArrRepeat);
    
    ' Actual resulting duration of the training block
    var trainBlockDurationActual := durationPerArrRepeat * nrepeats%;

    ' Initialize arrays to store delay timing values over an entire training block
    delayArrLen% := Round(tempArrLen%*nrepeats%);
    resize delayLabels%[delayArrLen%];
    var baseDelays%[delayArrLen%];
    var adjustedDelays%[delayArrLen%];   'Approach 1 adjusted delays (DelVal1)
    var channelValues%[delayArrLen%];    'Channel for first hemisphere (DelCh1: 3 or 4)

    ' Compute timing constants for this frequency
    var period := Round(sampleRate / chairFreq);
    var halfCycle := period / 2;
    var quarterCycle := halfCycle / 2;

    ' Compute inter-hemisphere delay (constant for all trials at this frequency)
    delayVal2% := Round(halfCycle - seqInterOverhead%);

    ' Populate the arrays
    var ii%, jj%, kk%, delay_jj%;
    for ii% := 0 to nrepeats%-1 do
        ' Shuffle array if random timing order is selected in settings
        if optoTimingOrder% = 0 then
            ArrSort(tempDelayArr%[], -1);
        endif;
        for jj% := 0 to tempArrLen%-1 do 
            delay_jj% := tempDelayArr%[jj%];
            baseDelays%[kk%] := delay_jj%;
            if delay_jj% = -1 then
                ' No stim case
                delayLabels%[kk%] := -1;
                adjustedDelays%[kk%] := -1;
                channelValues%[kk%] := -1;
            else
                ' Compute Approach 1 adjusted delay and channel
                ' Target = desired burst center time within cycle
                docase                        
                    case (delay_jj% < Round(halfCycle)) then
                        ' Target in first half: first hemisphere fires at target time
                        ' Channel 3 (DIGPS 2) fires first, channel 4 second
                        adjustedDelays%[kk%] := Round(delay_jj% + period - seqFixedOverhead%);
                        channelValues%[kk%] := 3;
                    case (delay_jj% >= Round(halfCycle)) then
                        ' Target in second half: fold to first half, swap channels
                        ' First hemisphere fires at (target - halfCycle)
                        ' Channel 4 (DIGPS 3) fires first, channel 3 second
                        adjustedDelays%[kk%] := Round((delay_jj% - halfCycle) + period - seqFixedOverhead%);
                        channelValues%[kk%] := 4;
                endcase;
                delayLabels%[kk%] := Round(delay_jj% - quarterCycle);
            endif;
            kk% := kk% + 1;
        next;
    next;

    PrintLog("Actual training block duration: %g s\n", trainBlockDurationActual);
    PrintLog("Delay timings per set: %d\n", tempArrLen%);
    PrintLog("Number of repeats of array set: %d\n", nrepeats%);
    PrintLog("Period: %d ms, HalfCycle: %g ms\n", period, halfCycle);
    PrintLog("DelVal2 (inter-hemisphere): %d ms\n", delayVal2%);
    PrintLog("seqFixedOverhead: %d ms, seqInterOverhead: %d ms\n", seqFixedOverhead%, seqInterOverhead%);
    PrintLog("\nbase delays: ", tempDelayArr%[]);
    PrintLog("Labels: ", delayLabels%[]);
    PrintLog("baseDelays: ", baseDelays%[]);
    PrintLog("adjustedDelays (DelVal1): ", adjustedDelays%[]);
    PrintLog("channelValues (DelCh1): ", channelValues%[], "\n");

    SampleSeqTable(adjustedDelays%[], 0);
    SampleSeqTable(channelValues%[], 5000);
End

Proc CheckDelayChange()
    var currStimNum% := SampleSeqVar(32); 'Current StimNum from sequencer
    var currDelayLabel%, smpltxt$;
    if (currStimNum% > 0) and (currStimNum% <> prevStimNum%) then
        currDelayLabel% := delayLabels%[currStimNum%-1];
        if currDelayLabel% = -1 then
            smpltxt$ := "NoStim";
        else
            smpltxt$ := Str$(currDelayLabel%)+"ms";
        endif;
        SampleText("("+smpltxt$+")", -1, 1);
        prevStimNum% := currStimNum%;
    endif;
End

Proc UpdateOptoParamsForSequencer()
    if digpsInterval% <= digpsDuration% then
        digpsInterval% := digpsDuration% + 1;
    endif;

    var pulseGap%;
    if digpsCycleCount% > 1 then
        pulseGap% := Round(digpsInterval% - digpsDuration%);
    else
        pulseGap% := 0;
    endif;

    optoDuration% := Round((digpsInterval% * digpsCycleCount%) - pulseGap%);
    ' Approach 1: No phase shift needed. Timing is handled entirely by the
    ' adjusted DELAY values computed in SetOptoDelays().
End

Func AddTextMark(samplekey$, blocknumber%)
    ' Search Index "Marker codes, Colour for" for more info on marker code colors
    var text$, code%;
    docase
        case samplekey$ = "G" then
            text$ := "GAP";
            code% := 1;
        case samplekey$ = "P" then
            if blockNum% <= Round(2*nTestBlocks%) then
                pretestBlockNum% := pretestBlockNum% + 1;
                text$ := "PRE#"+Str$(pretestBlockNum%);
                code% := 2;
                
            else
                posttestBlockNum% := posttestBlockNum% + 1;
                text$ := "POST#"+Str$(posttestBlockNum%);
                code% := 8;
                
            endif;
        case samplekey$ = "T" then
            trainBlockNum% := trainBlockNum% + 1;
            text$ := "TRAIN#"+Str$(trainBlockNum%);
            code% := 4;
    endcase;
    return SampleText(text$, -1, code%); 
End
